"Lazy Segment tree with both Range Add and Range Set": {
"scope": "cpp",
"prefix": "seglazy",
"body": [
"class Node {",
"public:",
"    ll add, chang;",
"    Node(ll a, ll b) :add(a), chang(b) {}",
"};",
"",
"//Lazy Propagating maximum segment tree",
"class SegTreeLazy {",
"public:",
"    int n;",
"    vc<pair<ll, Node>> tree;//Second is for lazy update",
"    SegTreeLazy(int siz) {",
"        int nearPow2 = (1 << (int)ceil(log2(siz)));",
"        n = nearPow2;",
"        tree.resize(2 * nearPow2, make_pair(0ll, Node(0ll, 0ll)));",
"    }",
"    ll get(int k) {",
"        return sum(k, k, 1, 1, n);",
"    }",
"    //n is the size of input",
"    //incase input is like size n+1",
"    void build(const vc<ll>& input) {",
"        for (int i = 0; i < (int)input.size(); ++i) {",
"            tree[n + i].first = input[i];",
"        }",
"        for (int i = n - 1; i >= 1; --i) {",
"            tree[i].first = tree[2 * i].first + tree[2 * i + 1].first;",
"        }",
"    }",
"",
"    void applyLazyUpdate(int k, int l, int r) {",
"        if (tree[k].second.add != 0) {",
"            tree[k].first += (ll)(r - l + 1) * tree[k].second.add;",
"            if (l != r) {",
"                if (tree[2 * k].second.chang != 0) {",
"                    tree[2 * k].second.chang += tree[k].second.add;",
"                }",
"                else {",
"                    tree[2 * k].second.add += tree[k].second.add;",
"                }",
"",
"                if (tree[2 * k + 1].second.chang != 0) {",
"                    tree[2 * k + 1].second.chang += tree[k].second.add;",
"                }",
"                else {",
"                    tree[2 * k + 1].second.add += tree[k].second.add;",
"                }",
"            }",
"            tree[k].second.add = 0;",
"        }",
"        if (tree[k].second.chang != 0) {",
"            tree[k].first = (ll)(r - l + 1) * tree[k].second.chang;",
"            if (l != r) {",
"                tree[2 * k].second.chang = tree[k].second.chang;",
"                tree[2 * k + 1].second.chang = tree[k].second.chang;",
"                tree[2 * k].second.add = 0;",
"                tree[2 * k + 1].second.add = 0;",
"            }",
"            tree[k].second.chang = 0;",
"        }",
"    }",
"",
"    ll sum(int a, int b, int k, int l, int r) {",
"        if (l > r) return 0;",
"        if(tree[k].second.add != 0 && tree[k].second.chang != 0) {",
"            cout << \"ERROR!\" << endl;",
"        }",
"        ",
"        applyLazyUpdate(k, l, r);",
"        if((k/2) >= 1) { //This is very important code you need to update the parents",
"            tree[k/2].first = tree[2*(k/2)].first + tree[2*(k/2) + 1].first;",
"        }",
"        if (b < l || a > r) {",
"            return 0;",
"        }",
"        if (l >= a && r <= b) return tree[k].first;",
"        int m = (l + r) / 2;",
"        auto res = sum(a, b, 2*k, l, m) + sum(a, b, 2*k + 1, m+1, r);",
"        if(l != r) {",
"            tree[k].first = tree[2*k].first + tree[2*k + 1].first;",
"        }",
"        return res;",
"    }",
"",
"    ll sum(int a, int b) {",
"        if (a > b) return 0;",
"        return sum(a, b, 1, 1, n);",
"    }",
"",
"    void set(int k, int u) {",
"        range_update_add(k, k, u - get(k));",
"    }",
"    void range_update_add(int a, int b, ll x) {",
"        range_update_add(a, b, x, 1, 1, n);",
"    }",
"    void range_update_add(int a, int b, ll x, int k, int l, int r) {",
"        if (l > r) return;",
"",
"        applyLazyUpdate(k, l, r);",
"",
"        if (a > r || b < l) return;",
"",
"        if (l >= a && r <= b) {",
"            tree[k].first += x * (ll)(r - l + 1);",
"            if (l != r) {",
"                if (tree[2 * k].second.chang != 0) {",
"                    tree[2 * k].second.chang += x;",
"                }",
"                else {",
"                    tree[2 * k].second.add += x;",
"                }",
"",
"                if (tree[2 * k + 1].second.chang != 0) {",
"                    tree[2 * k + 1].second.chang += x;",
"                }",
"                else {",
"                    tree[2 * k + 1].second.add += x;",
"                }",
"            }",
"            return;",
"        }",
"",
"        int m = (l + r) / 2;",
"        range_update_add(a, b, x, 2 * k, l, m);",
"        range_update_add(a, b, x, 2 * k + 1, m + 1, r);",
"        if (l != r) {",
"            tree[k].first = tree[2 * k].first + tree[2 * k + 1].first;",
"        }",
"    }",
"    void range_update_set(int a, int b, ll x) {",
"        range_update_set(a, b, x, 1, 1, n);",
"    }",
"    void range_update_set(int a, int b, ll x, int k, int l, int r) {",
"        if (l > r) return;",
"",
"        applyLazyUpdate(k, l, r);",
"        ",
"        if (a > r || b < l) return;",
"",
"        if (l >= a && r <= b) {",
"            tree[k].first = (ll)(r - l + 1) * x;",
"            if (l != r) {",
"                tree[2 * k].second.chang = x;",
"                tree[2 * k + 1].second.chang = x;",
"                tree[2 * k].second.add = 0;",
"                tree[2 * k + 1].second.add = 0;",
"            }",
"            return;",
"        }",
"",
"        int m = (l + r) / 2;",
"        range_update_set(a, b, x, 2 * k, l, m);",
"        range_update_set(a, b, x, 2 * k + 1, m + 1, r);",
"        if (l != r) {",
"            tree[k].first = tree[2 * k].first + tree[2 * k + 1].first;",
"        }",
"    }",
"};",
]
}