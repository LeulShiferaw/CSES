{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Disjoint set union": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"class DSU {",
    		"public:",
        	"    vector<int> parent;",
        	"    vector<int> size;",
    		"public:",
        	"    DSU(int n) :parent(n+1, -1), size(n+1, 1) {}",
        	"    int find(int n) {",
            "        if(parent[n] == -1) return n;",
            "        while(true)",
            "        {",
            "            if(parent[n] == -1) return n;",
            "            n = parent[n];",
            "        }",
        	"    }",
        	"    void unite(int a, int b) {",
        	"         int pa = find(a);",
        	"         int pb = find(b);",
        	"         if(pa == pb) return;",
        	"         if(size[pa] < size[pb]) swap(pa, pb);",
        	"         size[pa] += size[pb];",
        	"         parent[pb] = pa;",
        	"    }",
        	"    bool same(int a, int b) {",
        	"        return find(a) == find(b);",
        	"    }",
			"};"
        ], 
	"description" : "disjoint set union"
	}, 
	"Djikstras algo": {
		"scope": "cpp",
		"prefix": "dji",
		"body":[
			"vc<ll> djikstra(vc<pr<int>> graph[], int start, int n)",
			"{",
    		"    vc<ll>   dis(n+1, INF);",
    		"    vc<bool> used(n+1, false);",
    		"    dis[1] = 0;",
    		"    std::priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;",
    		"    pq.push(make_pair(0ll, start));",
    		"    while(!pq.empty()) {",
        	"        auto dist  = pq.top().first;",
        	"        int  node = pq.top().second;",
        	"        pq.pop();",
        	"        if(used[node]) {",
            "            continue;",
        	"        }",
        	"        used[node] = true;",
        	"        for(auto &element : graph[node]) {",
            "            if(dist + element.second < dis[element.first])",
            "            {",
            "                dis[element.first] = dist + element.second;",
            "                pq.push(make_pair(dis[element.first], element.first));",
            "            }",
        	"        }",
    		"    }",
    		"    return dis;",
			"}"
		],
		"description": "djikstra's algorithm"
	},
	"Topological sort":{
		"scope": "cpp",
		"prefix": "topo",
		"body": [
			"void topo_sort(vc<int> graph[], vc<int> &state, int curr, vc<int> &topology) {",
    		"    if(state[curr] == 2) return;",
    		"    state[curr] = 1;",
    		"    for(auto &node : graph[curr]) {",
        	"        topo_sort(graph, state, node, topology);",
    		"    }",
    		"    state[curr] = 2;",
    		"    topology.PB(curr);",
			"}",
			"",
			"vc<int> topo_sort(vc<int> graph[], int curr, int n) {",
    		"    vc<int> state(n+1, 0);",
    		"    vc<int> topology;",
    		"    topo_sort(graph, state, curr, topology);",
			"    reverse(topology.begin(), topology.end())",
    		"    return topology;",
			"}"
		]
	},
	"Sparse Table": {
		"scope": "cpp",
		"prefix": "sparse",
		"body": [
			"class SparseTable {",
			"	private:",
			"		vv<int> table; ",
			"	public:",
			"		SparseTable(int n) {",
			"			table.resize(n, vc<int>(floor(log2(n))+1));",
			"		}",
			"		void build(vc<int> &arr) { ",
			"			assert(arr.size() == table.size());",
			"			//For (1 << 0)",
			"			for(int i= 0; i<(int)table.size(); ++i) {",
			"				table[i][0] = arr[i];",
			"			}",
			"			//For (1 << i) where i >= 1",
			"			for(int i = 1; i<(int)table[0].size(); ++i) {",
			"				for(int j = 0; j<(int)table.size()-(1 << i) + 1; ++j) {",
			"					table[j][i] = min(table[j][i-1], table[j+(1 << (i-1))][i-1]);",
			"				}",
			"			}",
			"		}",
			"		int minQuery(int a, int b) {",
			"			int maxPow2 = floor(log2(b-a+1));",
			"			return min(table[a][maxPow2], table[b-(1 << maxPow2)+1][maxPow2]);",
			"		}",
			"};"
		]
	},
	"Fenwick Tree":{
		"scope":"cpp",
		"prefix": "fen",
		"body":[
			"#define LSOne(S) ((S) & (-(S)))",
			"class FenwickTree {",
			"	public:",
			"		vc<ll> tree;",
			"		vc<ll> orig_arr;",
			"		FenwickTree(int n) {",
			"			tree.resize(n+1, 0);",
			"		}",
			"		void build(const vc<ll> &input) {",
			"			assert(tree.size() == input.size());",
			"			orig_arr = input;",
			"			for(int i=1; i<(int)input.size(); ++i)",
			"			{",
			"				tree[i] += input[i];",
			"				int k = i + LSOne(i);",
			"				if(k < (int)tree.size())",
			"					tree[k] += tree[i];",
			"			}",
			"		}",
			"		void set(int k, int x) {",
			"			update(k, x - orig_arr[k]);",
			"			orig_arr[k] = x;",
			"		}",
			"		void update(int k, int x) {",
			"			while(k < (int)tree.size()) {",
			"				tree[k] += x;",
			"				k += LSOne(k);",
			"			}",
			"		}",
			"		ll sum(int k) {",
			"			ll res = 0;",
			"			while(k >= 1) {",
			"				res += tree[k];",
			"				k -= LSOne(k);",
			"			}",
			"			return res;",
			"		}",
			"		ll sum(int a, int b) {",
			"			return sum(b) - sum(a-1);",
			"		}",
			"};"
		]
	},
	"Segment Tree":{
		"scope": "cpp",
		"prefix": "seg",
		"body": [
			"//Uses 0 indexing",
			"class SegTree {",
			"	public: ",
			"		int n;",
			"		vc<ll> tree;",
			"		SegTree(int siz) {", 
			"			int nearPow2 = (1 << (int)ceil(log2(siz)));", 
			"			n = nearPow2;", 
			"			tree.resize(2*nearPow2, 0);", 
			"		}", 
			"		ll get(int k) {", 
			"			--k;", 
			"			return tree[n+k];", 
			"		}", 
			"		//n is the size of input", 
			"		//incase input is like size n+1", 
			"		void build(const vc<ll> &input) {", 
			"			for(int i=0; i<(int)input.size(); ++i) {", 
			"				tree[n+i] = input[i];", 
			"			}", 
			"			for(int i=n-1; i>=1; --i) {", 
			"				tree[i] = tree[2*i] + tree[2*i + 1];", 
			"			}", 
			"		}", 
			"		ll sum(int a, int b) {", 
			"			--a; --b;", 
			"			a += n; b += n;", 
			"			ll res = 0;", 
			"			while(a<=b) {", 
			"				if(a % 2 == 1) res = res + tree[a++];", 
			"				if(b % 2 == 0) res = res + tree[b--];", 
			"				a/=2; b/=2;", 
			"			}", 
			"			return res;", 
			"		}", 
			"		void set(int k, int u) {", 
			"			update(k, u-tree[k-1+n]);", 
			"		}", 
			"		void update(int k, int x) {", 
			"			--k;", 
			"			k += n;", 
			"			tree[k] += x;", 
			"			for(k/=2; k>=1; k/=2) {", 
			"				tree[k] = tree[2*k] + tree[2*k+1];", 
			"			}", 
			"		}", 
			"};"
		]
	},
	"Segment Tree Minimum":{
		"scope": "cpp",
		"prefix": "segmin",
		"body": [
			"//Uses 0 indexing",
			"class SegMinTree {",
			"	public: ",
			"		int n;",
			"		vc<ll> tree;",
			"		SegMinTree(int siz) {", 
			"			int nearPow2 = (1 << (int)ceil(log2(siz)));", 
			"			n = nearPow2;", 
			"			tree.resize(2*nearPow2, 0);", 
			"		}", 
			"		ll get(int k) {", 
			"			--k;", 
			"			return tree[n+k];", 
			"		}", 
			"		//n is the size of input", 
			"		//incase input is like size n+1", 
			"		void build(const vc<ll> &input) {", 
			"			for(int i=0; i<(int)input.size(); ++i) {", 
			"				tree[n+i] = input[i];", 
			"			}", 
			"			for(int i=n-1; i>=1; --i) {", 
			"				tree[i] = min(tree[2*i], tree[2*i + 1]);", 
			"			}", 
			"		}", 
			"		ll minimum(int a, int b) {", 
			"			--a; --b;", 
			"			a += n; b += n;", 
			"			ll res = INT_MAX;", 
			"			while(a<=b) {", 
			"				if(a % 2 == 1) res = min(res, tree[a++]);", 
			"				if(b % 2 == 0) res = min(res, tree[b--]);", 
			"				a/=2; b/=2;", 
			"			}", 
			"			return res;", 
			"		}", 
			"		void set(int k, int u) {", 
			"			update(k, u-tree[k-1+n]);", 
			"		}", 
			"		void update(int k, int x) {", 
			"			--k;", 
			"			k += n;", 
			"			tree[k] += x;", 
			"			for(k/=2; k>=1; k/=2) {", 
			"				tree[k] = min(tree[2*k], tree[2*k+1]);", 
			"			}", 
			"		}", 
			"};"
		]
	},
	"Segment Tree Maximum":{
		"scope": "cpp",
		"prefix": "segmax",
		"body": [
			"//Uses 0 indexing",
			"class SegMaxTree {",
			"	public: ",
			"		int n;",
			"		vc<ll> tree;",
			"		SegMaxTree(int siz) {", 
			"			int nearPow2 = (1 << (int)ceil(log2(siz)));", 
			"			n = nearPow2;", 
			"			tree.resize(2*nearPow2, 0);", 
			"		}", 
			"		ll get(int k) {", 
			"			--k;", 
			"			return tree[n+k];", 
			"		}", 
			"		//n is the size of input", 
			"		//incase input is like size n+1", 
			"		void build(const vc<ll> &input) {", 
			"			for(int i=0; i<(int)input.size(); ++i) {", 
			"				tree[n+i] = input[i];", 
			"			}", 
			"			for(int i=n-1; i>=1; --i) {", 
			"				tree[i] = max(tree[2*i], tree[2*i + 1]);", 
			"			}", 
			"		}", 
			"		ll maximum(int a, int b) {", 
			"			--a; --b;", 
			"			a += n; b += n;", 
			"			ll res = -1;", 
			"			while(a<=b) {", 
			"				if(a % 2 == 1) res = max(res, tree[a++]);", 
			"				if(b % 2 == 0) res = max(res, tree[b--]);", 
			"				a/=2; b/=2;", 
			"			}", 
			"			return res;", 
			"		}", 
			"		void set(int k, int u) {", 
			"			update(k, u-tree[k-1+n]);", 
			"		}", 
			"		void update(int k, int x) {", 
			"			--k;", 
			"			k += n;", 
			"			tree[k] += x;", 
			"			for(k/=2; k>=1; k/=2) {", 
			"				tree[k] = max(tree[2*k], tree[2*k+1]);", 
			"			}", 
			"		}", 
			"};"
		]
	},
	"Maximum Lazy Propagation Segment Tree": {
		"scope": "cpp",
		"prefix": "segmaxlazy",
		"body": [
		"//Lazy Propagating maximum segment tree",
		"class SegMaxTreeLazy{",
		"    public: ",
		"        int n;",
		"        vc<pair<ll, ll>> tree;//Second is for lazy update",
		"        SegMaxTreeLazy(int siz) {",
		"            int nearPow2 = (1 << (int)ceil(log2(siz)));",
		"            n = nearPow2;",
		"            tree.resize(2*nearPow2, make_pair(0ll, 0ll));",
		"        }",
		"        ll get(int k) {",
		"            return maximum(k, k, 1, 1, n);",
		"        }",
		"        //n is the size of input",
		"        //incase input is like size n+1",
		"        void build(const vc<ll> &input) {",
		"            for(int i=0; i<(int)input.size(); ++i) {",
		"                tree[n+i].first = input[i];",
		"            }",
		"            for(int i=n-1; i>=1; --i) {",
		"                tree[i].first = max(tree[2*i].first, tree[2*i + 1].first);",
		"            }",
		"        }",
		"",
		"        ll maximum(int a, int b, int k, int l, int r) {",
		"            if(tree[k].second != 0) {",
		"                tree[k].first += tree[k].second;",
		"                if(l != r) {",
		"                    tree[2*k].second += tree[k].second;",
		"                    tree[2*k + 1].second += tree[k].second;",
		"                }",
		"                tree[k].second = 0;",
		"            }",
		"            if(b < l || a > r) {",
		"                return -LLONG_MAX;",
		"            }",
		"            if(l >= a && r <= b) return tree[k].first;",
		"            int m = (l+r)/2;",
		"            return max(maximum(a, b, 2*k, l, m), maximum(a, b, 2*k + 1, m+1, r));",
		"        }",
		"",
		"        ll maximum(int a, int b) {",
		"            return maximum(a, b, 1, 1, n);",
		"        }",
		"",
		"        void set(int k, int u) {",
		"            range_update(k, k, u-get(k));",
		"        }",
		"        void range_update(int a, int b, ll x) {",
		"            range_update(a, b, x, 1, 1, n);",
		"        }",
		"        void range_update(int a, int b, ll x, int k, int l, int r) {",
		"            if(l > r) return;",
		"",
		"            if(tree[k].second != 0) {",
		"                tree[k].first += tree[k].second;",
		"                if(l != r) {",
		"                    tree[2*k].second += tree[k].second;",
		"                    tree[2*k + 1].second += tree[k].second;",
		"                }",
		"                tree[k].second = 0;",
		"            }",
		"",
		"            if(a > r || b < l) return;",
		"",
		"            if(l >= a && r <= b) {",
		"                tree[k].first += x;",
		"                if(l != r) {",
		"                    tree[2*k].second += x;",
		"                    tree[2*k+1].second += x;",
		"                }",
		"                return;",
		"            }",
		"",
		"            int m = (l+r)/2;",
		"            range_update(a, b, x, 2*k, l, m);",
		"            range_update(a, b, x, 2*k+1, m+1, r);",
		"            if(l != r) {",
		"                tree[k].first = max(tree[2*k].first, tree[2*k+1].first);",
		"            }",
		"        }",
		"};"
		]
	},
	"Minimum Lazy Segment tree": {
		"scope": "cpp",
		"prefix": "segminlazy",
		"body": [
		"//Lazy Propagating maximum segment tree",
		"class SegMinTreeLazy{",
		"    public: ",
		"        int n;",
		"        vc<pair<ll, ll>> tree;//Second is for lazy update",
		"        SegMinTreeLazy(int siz) {",
		"            int nearPow2 = (1 << (int)ceil(log2(siz)));",
		"            n = nearPow2;",
		"            tree.resize(2*nearPow2, make_pair(0ll, 0ll));",
		"        }",
		"        ll get(int k) {",
		"            return minimum(k, k, 1, 1, n);",
		"        }",
		"        //n is the size of input",
		"        //incase input is like size n+1",
		"        void build(const vc<ll> &input) {",
		"            for(int i=0; i<(int)input.size(); ++i) {",
		"                tree[n+i].first = input[i];",
		"            }",
		"            for(int i=n-1; i>=1; --i) {",
		"                tree[i].first = min(tree[2*i].first, tree[2*i + 1].first);",
		"            }",
		"        }",
		"",
		"        ll minimum(int a, int b, int k, int l, int r) {",
		"            if(tree[k].second != 0) {",
		"                tree[k].first += tree[k].second;",
		"                if(l != r) {",
		"                    tree[2*k].second += tree[k].second;",
		"                    tree[2*k + 1].second += tree[k].second;",
		"                }",
		"                tree[k].second = 0;",
		"            }",
		"            if(b < l || a > r) {",
		"                return LLONG_MAX;",
		"            }",
		"            if(l >= a && r <= b) return tree[k].first;",
		"            int m = (l+r)/2;",
		"            return min(minimum(a, b, 2*k, l, m), minimum(a, b, 2*k + 1, m+1, r));",
		"        }",
		"",
		"        ll minimum(int a, int b) {",
		"            return minimum(a, b, 1, 1, n);",
		"        }",
		"",
		"        void set(int k, int u) {",
		"            range_update(k, k, u-get(k));",
		"        }",
		"        void range_update(int a, int b, ll x) {",
		"            range_update(a, b, x, 1, 1, n);",
		"        }",
		"        void range_update(int a, int b, ll x, int k, int l, int r) {",
		"            if(l > r) return;",
		"",
		"            if(tree[k].second != 0) {",
		"                tree[k].first += tree[k].second;",
		"                if(l != r) {",
		"                    tree[2*k].second += tree[k].second;",
		"                    tree[2*k + 1].second += tree[k].second;",
		"                }",
		"                tree[k].second = 0;",
		"            }",
		"",
		"            if(a > r || b < l) return;",
		"",
		"            if(l >= a && r <= b) {",
		"                tree[k].first += x;",
		"                if(l != r) {",
		"                    tree[2*k].second += x;",
		"                    tree[2*k+1].second += x;",
		"                }",
		"                return;",
		"            }",
		"",
		"            int m = (l+r)/2;",
		"            range_update(a, b, x, 2*k, l, m);",
		"            range_update(a, b, x, 2*k+1, m+1, r);",
		"            if(l != r) {",
		"                tree[k].first = min(tree[2*k].first, tree[2*k+1].first);",
		"            }",
		"        }",
		"};",
		]
	},
	"2D Segment Tree": {
		"scope": "cpp",
		"prefix": "seg2d",
		"body": [
		"//2d segment tree. update01 only works for switching b/n 0 and 1",
		"//Only works for nxn grids",
		"class SegTree2D {",
		"public:",
		"    int n;",
		"    vc<SegTree> tree;",
		"    SegTree2D(int siz) {",
		"        int nearPow2 = (1 << (int)ceil(log2(siz)));",
		"        n = nearPow2;",
		"        tree.resize(2 * nearPow2, SegTree(siz));",
		"    }",
		"    //Assuming input is nxn",
		"    void build(const vc<vc<ll>>& input) {",
		"        for (int i = 0; i < (int)input.size(); ++i) {",
		"            tree[n + i].build(input[i]);",
		"        }",
		"        for (int i = n - 1; i >= 1; --i) {",
		"            for (int j = 0; j < (int)tree[i].tree.size(); ++j) {",
		"                tree[i].tree[j] = tree[2 * i].tree[j] + tree[2 * i + 1].tree[j];",
		"            }",
		"        }",
		"    }",
		"",
		"    ll sum(int a, int b, int c1, int c2) {",
		"        --a; --b;",
		"        a += n; b += n;",
		"        ll res = 0;",
		"        while (a <= b) {",
		"            if (a % 2 == 1) {",
		"                res += tree[a++].sum(c1, c2);",
		"            }",
		"            if (b % 2 == 0) {",
		"                res += tree[b--].sum(c1, c2);",
		"            }",
		"            a /= 2; b /= 2;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    void update01(int r, int c) {",
		"        --r;",
		"        r += n; int add = 0;",
		"        if (tree[r].get(c) == 1) {",
		"            add = -1;",
		"        }",
		"        else {",
		"            add = 1;",
		"        }",
		"        tree[r].update(c, add);",
		"        while (r >= 1) {",
		"            r /= 2;",
		"            tree[r].update(c, add);", 
		"        }",
		"    }",
		"    void update(int r, int c, int x) {",
		"        --r;",
		"        r += n;",
		"        tree[r].update(c, x);",
		"        for (r /= 2; r >= 1; r /= 2) {",
		"            tree[r].update(c, x);",
		"        }",
		"    }",
		"    void show() {",
		"        for (int i = 1; i < (int)tree.size(); ++i) {",
		"            display(tree[i].tree);",
		"        }",
		"    }",
		"};",
		]
	},
	"Lazy Segment tree with both Range Add and Range Set": {
		"scope": "cpp",
		"prefix": "seglazy",
		"body": [
		"class Node {",
		"public:",
		"    ll add, chang;",
		"    Node(ll a, ll b) :add(a), chang(b) {}",
		"};",
		"",
		"//Lazy Propagating maximum segment tree",
		"class SegTreeLazy {",
		"public:",
		"    int n;",
		"    vc<pair<ll, Node>> tree;//Second is for lazy update",
		"    SegTreeLazy(int siz) {",
		"        int nearPow2 = (1 << (int)ceil(log2(siz)));",
		"        n = nearPow2;",
		"        tree.resize(2 * nearPow2, make_pair(0ll, Node(0ll, 0ll)));",
		"    }",
		"    ll get(int k) {",
		"        return sum(k, k, 1, 1, n);",
		"    }",
		"    //n is the size of input",
		"    //incase input is like size n+1",
		"    void build(const vc<ll>& input) {",
		"        for (int i = 0; i < (int)input.size(); ++i) {",
		"            tree[n + i].first = input[i];",
		"        }",
		"        for (int i = n - 1; i >= 1; --i) {",
		"            tree[i].first = tree[2 * i].first + tree[2 * i + 1].first;",
		"        }",
		"    }",
		"",
		"    void applyLazyUpdate(int k, int l, int r) {",
		"        if (tree[k].second.add != 0) {",
		"            tree[k].first += (ll)(r - l + 1) * tree[k].second.add;",
		"            if (l != r) {",
		"                if (tree[2 * k].second.chang != 0) {",
		"                    tree[2 * k].second.chang += tree[k].second.add;",
		"                }",
		"                else {",
		"                    tree[2 * k].second.add += tree[k].second.add;",
		"                }",
		"",
		"                if (tree[2 * k + 1].second.chang != 0) {",
		"                    tree[2 * k + 1].second.chang += tree[k].second.add;",
		"                }",
		"                else {",
		"                    tree[2 * k + 1].second.add += tree[k].second.add;",
		"                }",
		"            }",
		"            tree[k].second.add = 0;",
		"        }",
		"        if (tree[k].second.chang != 0) {",
		"            tree[k].first = (ll)(r - l + 1) * tree[k].second.chang;",
		"            if (l != r) {",
		"                tree[2 * k].second.chang = tree[k].second.chang;",
		"                tree[2 * k + 1].second.chang = tree[k].second.chang;",
		"                tree[2 * k].second.add = 0;",
		"                tree[2 * k + 1].second.add = 0;",
		"            }",
		"            tree[k].second.chang = 0;",
		"        }",
		"    }",
		"",
		"    ll sum(int a, int b, int k, int l, int r) {",
		"        if (l > r) return 0;",
		"        if(tree[k].second.add != 0 && tree[k].second.chang != 0) {",
		"            cout << \"ERROR!\" << endl;",
		"        }",
		"        ",
		"        applyLazyUpdate(k, l, r);",
		"        if((k/2) >= 1) { //This is very important code you need to update the parents",
		"            tree[k/2].first = tree[2*(k/2)].first + tree[2*(k/2) + 1].first;",
		"        }",
		"        if (b < l || a > r) {",
		"            return 0;",
		"        }",
		"        if (l >= a && r <= b) return tree[k].first;",
		"        int m = (l + r) / 2;",
		"        auto res = sum(a, b, 2*k, l, m) + sum(a, b, 2*k + 1, m+1, r);",
		"        if(l != r) {",
		"            tree[k].first = tree[2*k].first + tree[2*k + 1].first;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    ll sum(int a, int b) {",
		"        if (a > b) return 0;",
		"        return sum(a, b, 1, 1, n);",
		"    }",
		"",
		"    void set(int k, int u) {",
		"        range_update_add(k, k, u - get(k));",
		"    }",
		"    void range_update_add(int a, int b, ll x) {",
		"        range_update_add(a, b, x, 1, 1, n);",
		"    }",
		"    void range_update_add(int a, int b, ll x, int k, int l, int r) {",
		"        if (l > r) return;",
		"",
		"        applyLazyUpdate(k, l, r);",
		"",
		"        if (a > r || b < l) return;",
		"",
		"        if (l >= a && r <= b) {",
		"            tree[k].first += x * (ll)(r - l + 1);",
		"            if (l != r) {",
		"                if (tree[2 * k].second.chang != 0) {",
		"                    tree[2 * k].second.chang += x;",
		"                }",
		"                else {",
		"                    tree[2 * k].second.add += x;",
		"                }",
		"",
		"                if (tree[2 * k + 1].second.chang != 0) {",
		"                    tree[2 * k + 1].second.chang += x;",
		"                }",
		"                else {",
		"                    tree[2 * k + 1].second.add += x;",
		"                }",
		"            }",
		"            return;",
		"        }",
		"",
		"        int m = (l + r) / 2;",
		"        range_update_add(a, b, x, 2 * k, l, m);",
		"        range_update_add(a, b, x, 2 * k + 1, m + 1, r);",
		"        if (l != r) {",
		"            tree[k].first = tree[2 * k].first + tree[2 * k + 1].first;",
		"        }",
		"    }",
		"    void range_update_set(int a, int b, ll x) {",
		"        range_update_set(a, b, x, 1, 1, n);",
		"    }",
		"    void range_update_set(int a, int b, ll x, int k, int l, int r) {",
		"        if (l > r) return;",
		"",
		"        applyLazyUpdate(k, l, r);",
		"        ",
		"        if (a > r || b < l) return;",
		"",
		"        if (l >= a && r <= b) {",
		"            tree[k].first = (ll)(r - l + 1) * x;",
		"            if (l != r) {",
		"                tree[2 * k].second.chang = x;",
		"                tree[2 * k + 1].second.chang = x;",
		"                tree[2 * k].second.add = 0;",
		"                tree[2 * k + 1].second.add = 0;",
		"            }",
		"            return;",
		"        }",
		"",
		"        int m = (l + r) / 2;",
		"        range_update_set(a, b, x, 2 * k, l, m);",
		"        range_update_set(a, b, x, 2 * k + 1, m + 1, r);",
		"        if (l != r) {",
		"            tree[k].first = tree[2 * k].first + tree[2 * k + 1].first;",
		"        }",
		"    }",
		"};",
		]
	},
	"Polynomial Update lazy segment tree for u+1 only": {
		"scope": "cpp",
		"prefix": "polyseg",
		"body": [
		"class Node {",
		"public:",
		"    ll z0, z1;",
		"    Node(ll a, ll b) :z0(a), z1(b) {}",
		"};",
		"",
		"//Lazy Propagating maximum segment tree",
		"class PolySegTreeLazy {",
		"public:",
		"    int n;",
		"    vc<pair<ll, Node>> tree;//Second is for lazy update",
		"    PolySegTreeLazy(int siz) {",
		"        int nearPow2 = (1 << (int)ceil(log2(siz)));",
		"        n = nearPow2;",
		"        tree.resize(2 * nearPow2, make_pair(0ll, Node(0ll, 0ll)));",
		"    }",
		"    ll get(int k) {",
		"        return sum(k, k, 1, 1, n);",
		"    }",
		"    //n is the size of input",
		"    //incase input is like size n+1",
		"    void build(const vc<ll>& input) {",
		"        for (int i = 0; i < (int)input.size(); ++i) {",
		"            tree[n + i].first = input[i];",
		"        }",
		"        for (int i = n - 1; i >= 1; --i) {",
		"            tree[i].first = tree[2 * i].first + tree[2 * i + 1].first;",
		"        }",
		"    }",
		"",
		"    void applyLazyUpdate(ll k, ll l, ll r) {",
		"        int m = (r+l)/2;",
		"        if(tree[k].second.z1 != 0) {",
		"            tree[k].first += tree[k].second.z1*((r-l)*(r-l+1))/2 + tree[k].second.z0*(r-l+1);",
		"            if(l != r) {",
		"                tree[2*k].second.z1 += tree[k].second.z1;",
		"                tree[2*k].second.z0 += tree[k].second.z0;",
		"                tree[2*k + 1].second.z1 += tree[k].second.z1;",
		"                tree[2*k + 1].second.z0 += tree[k].second.z0 + (m+1-l) * tree[k].second.z1; // I don't know why we are multiplying with z1",
		"            }",
		"            tree[k].second.z1 = 0;",
		"            tree[k].second.z0 = 0;",
		"        }",
		"    }",
		"",
		"    ll sum(ll a, ll b, ll k, ll l, ll r) {",
		"        if (l > r) return 0;",
		"        applyLazyUpdate(k, l, r);",
		"        if((k/2) >= 1) { //This is very important code you need to update the parents",
		"            tree[k/2].first = tree[2*(k/2)].first + tree[2*(k/2) + 1].first;",
		"        }",
		"        if (b < l || a > r) {",
		"            return 0;",
		"        }",
		"        if (l >= a && r <= b) return tree[k].first;",
		"        int m = (l + r) / 2;",
		"        auto res = sum(a, b, 2*k, l, m) + sum(a, b, 2*k + 1, m+1, r);",
		"        if(l != r) {",
		"            tree[k].first = tree[2*k].first + tree[2*k + 1].first;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    ll sum(int a, int b) {",
		"        if (a > b) return 0;",
		"        return sum(a, b, 1, 1, n);",
		"    }",
		"",
		"    void range_update_add(ll a, ll b) {",
		"        range_update_add(a, b, 1ll, 1ll, n);",
		"    }",
		"    void range_update_add(ll a, ll b, ll k, ll l, ll r) {",
		"        if (l > r) return;",
		"",
		"        applyLazyUpdate(k, l, r);",
		"        if((k/2) >= 1) { //This is very important code you need to update the parents",
		"            tree[k/2].first = tree[2*(k/2)].first + tree[2*(k/2) + 1].first;",
		"        }",
		"        if (a > r || b < l) return;",
		"",
		"        int m = (l + r) / 2;",
		"        if (l >= a && r <= b) {",
		"            tree[k].first += ((r-l)*(r-l+1))/2 + (l-a+1)*(r-l+1);",
		"            if (l != r) {",
		"                tree[2*k].second.z1++;",
		"                tree[2*k].second.z0 += l-a+1;",
		"                tree[2*k + 1].second.z1++;",
		"                tree[2*k + 1].second.z0 += m-a+2;",
		"            }",
		"            return;",
		"        }",
		"",
		"        range_update_add(a, b, 2 * k, l, m);",
		"        range_update_add(a, b, 2 * k + 1, m + 1, r);",
		"        if (l != r) {",
		"            tree[k].first = tree[2 * k].first + tree[2 * k + 1].first;",
		"        }",
		"    }",
		"};",
		]
	},
	"Persistent Segment tree": {
		"scope": "cpp",
		"prefix": "persseg",
		"body": [
		"//For problem Range Queries and Copies",
		"//Data structure for Persistent Segment trees",
		"//You still have to declare the vectore of Node* for the versions",
		"//Also another vector that points to kth version because versions may not",
		"//be ordered interms of the versions. When you change the value of kth version",
		"//you aren't supposed to add a new version at the bottom you are supposed to",
		"//change the current version. So use another vector to maintain the versions",
		"//But when you change a new element you still add that as a new version.",
		"class Node {",
		"    public:",
		"        int n;",
		"        ll val;",
		"        Node *left, *right;",
		"        Node(ll a, Node *l, Node *r, int newN) :val(a), left(l), right(r), n(newN) {};",
		"        ~Node() {",
		"            destroy(this);",
		"        }",
		"",
		"        void build(vc<ll> &input) {",
		"            int nearPow2 = (1 << (int)ceil(log2(input.size())));",
		"            n = nearPow2;",
		"            build(this, input, 1, nearPow2);",
		"        }",
		"        void build(Node *curr, vc<ll> &input, int l, int r) {",
		"            if(l == r) {",
		"                if(l > (int)input.size()) return;",
		"                curr->val = input[l-1];",
		"                return;",
		"            }",
		"",
		"            int m = (l+r)/2;",
		"            curr->left = new Node(0, nullptr, nullptr, m-l+1);",
		"            curr->right = new Node(0, nullptr, nullptr, r-m);",
		"            build(curr->left, input, l, m);",
		"            build(curr->right, input, m+1, r);",
		"            curr->val = curr->left->val + curr->right->val;",
		"        }",
		"        void destroy() {",
		"            destroy(this);",
		"        }",
		"        void destroy(Node *node) {",
		"            if(node == nullptr) return;",
		"            destroy(node->left);",
		"            destroy(node->right);",
		"            delete node;",
		"            node = nullptr;",
		"        }",
		"        void display() {",
		"            display(this);",
		"        }",
		"        void display(Node *node) {",
		"            if(node == nullptr) return;",
		"            if(node->left == nullptr && node->right == nullptr) {",
		"                cout << node->val << " ";",
		"                return;",
		"            }",
		"            cout << node->val << " ";",
		"            display(node->left);",
		"            display(node->right);",
		"        }",
		"        ll sum(int a, int b) {",
		"            return sum(this, a, b, 1, n);",
		"        }",
		"        ll sum(Node *curr, int a, int b, int l, int r) {",
		"            if(l >= a && r <= b) return curr->val;",
		"            if(l > b || r < a) return 0;",
		"            int m = (l+r)/2;",
		"            return sum(curr->left, a, b, l, m) + sum(curr->right, a, b, m+1, r);",
		"        }",
		"        void updateSet(int k, int x) {",
		"            updateSet(this, 1, n, k, x); ",
		"        }",
		"        void updateSet(Node *curr, int l, int r, int k, int x) {",
		"            if(k < l || k > r || l > r) return;",
		"            if(l == r) {",
		"                curr->val = x;",
		"                return;",
		"            }",
		"",
		"            int m = (l+r)/2;",
		"            if(k <= m)  {",
		"                updateSet(curr->left, l, m, k, x);",
		"            }",
		"            else {",
		"                updateSet(curr->right, m+1, r, k, x);",
		"            }",
		"            curr->val = curr->left->val + curr->right->val;",
		"        }",
		"        ",
		"};",
		"",
		"void updateNewVersion(Node *prev, Node *curr, int l, int r, int k, int x) {",
		"    if(k < l || k > r || l > r) return;",
		"    if(l == r) {",
		"        curr->val = x;",
		"        return;",
		"    }",
		"",
		"    int m = (l+r)/2;",
		"    if(k <= m)  {",
		"        curr->right = prev->right;",
		"        curr->left = new Node(0, nullptr, nullptr, 0);",
		"        updateNewVersion(prev->left, curr->left, l, m, k, x);",
		"    }",
		"    else {",
		"        curr->left = prev->left;",
		"        curr->right = new Node(0, nullptr, nullptr, 0);",
		"        updateNewVersion(prev->right, curr->right, m+1, r, k, x);",
		"    }",
		"    curr->val = curr->left->val + curr->right->val;",
		"}",
		"",
		"void updateNewVersion(Node *prev, Node *curr, int k, int x) {",
		"    curr->n = prev->n;",
		"    updateNewVersion(prev, curr, 1, curr->n, k, x);",
		"}",
		]
	},
	"Modular Exponentiation": {
		"scope": "cpp",
		"prefix": "expon",
		"body": [
		"ll exp(int a, int b) {",
		"    if(b == 0) return 1;",
		"    if(b == 1) return a;",
		"",
		"    if(b%2 == 0) {",
		"        ll temp = exp(a, b/2);",
		"        return (temp * temp) % MOD;",
		"    }",
		"    else return (a*exp(a, b-1)) % MOD;",
		"}",
		"",
		"ll exp2(int a, long long b) {",
		"    if(b < MOD) return exp(a, b);",
		"    return exp(a, b % (MOD-1));",
		"}",
		]
	}
}